# -*- coding: utf-8 -*-
"""
Presto MAX â€” Job Cost Calculator
Streamlit application to estimate the production cost for a specific job
(roll) on the Presto MAX printer.
"""

from __future__ import annotations

import io
import os
import re
import zipfile
import tempfile
import xml.etree.ElementTree as ET
import datetime as dt
import calendar
from typing import Dict, Tuple, List, Any

import numpy as np  # type: ignore
import pandas as pd  # type: ignore
import streamlit as st
import matplotlib.pyplot as plt  # type: ignore
import plotly.graph_objects as go  # type: ignore

# Optional PDF support
try:
    from fpdf import FPDF  # type: ignore
except Exception:  # pragma: no cover
    FPDF = None  # type: ignore

# Optional ControlCenter PDF reader
try:
    from PyPDF2 import PdfReader  # type: ignore
except Exception:  # pragma: no cover
    PdfReader = None  # type: ignore

# -------------------------------------------------------------------------
# Helpers para ROI / Payback (LÃ³gica Financeira)
# -------------------------------------------------------------------------

def _clamp(value: float, low: float = 0.0, high: float = 1.0) -> float:
    try:
        return max(low, min(high, float(value)))
    except Exception:
        return low

def _add_months(base: dt.date, months: int) -> dt.date:
    months = int(months or 0)
    month = base.month - 1 + months
    year = base.year + month // 12
    month = month % 12 + 1
    day = min(base.day, calendar.monthrange(year, month)[1])
    return dt.date(year, month, day)

def pretty_money(v, symbol="$", fx=1.0) -> str:
    try: val = float(v)
    except Exception: val = 0.0
    val *= (fx or 1.0)
    return f"{symbol} {val:,.2f}"

def compute_payback_schedule(
    initial_investment: float,
    steady_cash: float,
    horizon_months: int,
    ramp_months: int,
    ramp_start_ratio: float,
    growth_rate: float,
) -> tuple[int | None, List[Dict[str, float]], float]:
    """Gera a tabela de payback mensal com rampa de subida e crescimento."""
    inv = float(initial_investment or 0.0)
    steady = float(steady_cash or 0.0)
    horizon = max(1, int(horizon_months or 0))
    ramp_m = max(0, int(ramp_months or 0))
    ramp_start = _clamp(ramp_start_ratio, 0.0, 1.0)
    growth = float(growth_rate or 0.0)
    if growth <= -0.99: growth = -0.99

    cumulative = -inv
    payback_month: int | None = None
    schedule: List[Dict[str, float]] = []

    if horizon <= 0:
        return payback_month, schedule, cumulative

    for month in range(1, horizon + 1):
        # Fator de rampa (eficiÃªncia inicial)
        if ramp_m <= 1:
            ramp_factor = 1.0 if ramp_m == 0 else 1.0
        elif month <= ramp_m:
            progress = (month - 1) / max(ramp_m - 1, 1)
            ramp_factor = _clamp(ramp_start + (1.0 - ramp_start) * progress, 0.0, 1.0)
        else:
            ramp_factor = 1.0

        # Fator de crescimento pÃ³s-rampa
        periods_after_ramp = 0
        if ramp_m == 0:
            periods_after_ramp = max(0, month - 1)
        else:
            periods_after_ramp = max(0, month - ramp_m)
        growth_multiplier = (1.0 + growth) ** periods_after_ramp if growth != 0 else 1.0

        # Fluxo de caixa do mÃªs
        cash = steady * ramp_factor * growth_multiplier
        cumulative += cash

        schedule.append({
            "month": float(month),
            "cash": float(cash),
            "cumulative": float(cumulative),
            "utilization_pct": float(ramp_factor * 100.0),
            "growth_multiplier": float(growth_multiplier),
        })
        if payback_month is None and cumulative >= 0:
            payback_month = month

    return payback_month, schedule, cumulative

def plotly_cfg():
    return {"displaylogo": False, "toImageButtonOptions": {"format": "png", "scale": 2}}

# -------------------------------------------------------------------------
# Visual settings
# -------------------------------------------------------------------------

PALETTE_MAIN = [
    "#4F75C2",  # muted blue
    "#7A97D4",  # soft blue
    "#A3B7E6",  # very soft blue
    "#6B7280",  # muted grey
    "#CBD5F5",  # very light blue
]
PALETTE_SECONDARY = [
    "#10B981",  # soft green
    "#F59E0B",  # soft amber
]

plt.rcParams.update(
    {
        "axes.edgecolor": "#E5E7EB",
        "axes.grid": True,
        "grid.color": "#E5E7EB",
        "grid.linestyle": "--",
        "grid.linewidth": 0.7,
        "axes.spines.top": False,
        "axes.spines.right": False,
        "axes.spines.left": False,
        "axes.spines.bottom": False,
        "figure.figsize": (5.5, 3.4),
        "axes.titlesize": 11,
        "axes.labelsize": 9,
        "xtick.labelsize": 8,
        "ytick.labelsize": 8,
    }
)

# -------------------------------------------------------------------------
# Constants
# -------------------------------------------------------------------------

PRINT_MODES: Dict[str, Dict[str, object]] = {
    "Fast Quality":         {"speed": 270.0, "res_color": "800Ã—400"},
    "Fast Production":      {"speed": 475.0, "res_color": "800Ã—400"},
    "Standard Quality":     {"speed": 180.0, "res_color": "600Ã—800"},
    "Standard Production":  {"speed": 278.0, "res_color": "600Ã—800"},
    "Saturation Quality":   {"speed": 115.0, "res_color": "1000Ã—800"},
    "Saturation Production":{"speed": 210.0, "res_color": "1000Ã—800"},
}

CHANNELS_WHITE = {"white", "w"}
CHANNELS_FOF = {
    "fof", "f", "fix", "fixation", "pretreat", "pre_treat",
    "duosoft", "softener", "fixacao", "fixacaofof"
}

# -------------------------------------------------------------------------
# XML helpers
# -------------------------------------------------------------------------

def parse_presto_xml(xml_bytes: bytes) -> Tuple[float, Dict[str, float]]:
    """Parse XML from Presto MAX and return (area_m2, {sep: ml_total})."""
    root = ET.fromstring(xml_bytes)

    def _to_float(x: str) -> float:
        try:
            return float(x)
        except Exception:
            return 0.0

    width_cm = _to_float(root.findtext("Width", "0"))
    height_cm = _to_float(root.findtext("Height", "0"))
    area_m2 = (width_cm / 100.0) * (height_cm / 100.0)

    ml_node = root.find("NumberOfMlPerSeparation")
    if ml_node is None:
        ml_node = root.find("NumberOfMlPerSeperation")

    ml_per_sep: Dict[str, float] = {}
    if ml_node is not None:
        for child in ml_node:
            try:
                ml_per_sep[child.tag] = float(child.text or "0")
            except Exception:
                ml_per_sep[child.tag] = 0.0

    return area_m2, ml_per_sep


def normalize_sep_name(name: str) -> str:
    """Normalise separation names to friendly labels."""
    n = (name or "").strip()
    lower = n.lower()
    if lower.startswith("whi"):
        return "White"
    if lower.startswith(("fof", "fix", "pretreat", "pre_treat")):
        return "FOF"
    return n


def ml_per_m2_from_xml_bytes(xml_bytes: bytes) -> Dict[str, float]:
    """Return ml/mÂ² per separation from XML bytes."""
    area, ml_sep = parse_presto_xml(xml_bytes)
    out: Dict[str, float] = {}
    if area > 0:
        for sep, ml_total in ml_sep.items():
            out[normalize_sep_name(sep)] = ml_total / area
    return out


def pick_xml_from_zip(zbytes: bytes) -> Tuple[str | None, bytes | None]:
    """Return (xml_name, xml_bytes) for first XML in ZIP or (None, None)."""
    with zipfile.ZipFile(io.BytesIO(zbytes)) as z:
        xml_files = [n for n in z.namelist() if n.lower().endswith(".xml")]
        if not xml_files:
            return None, None
        first = xml_files[0]
        return first, z.read(first)


# -------------------------------------------------------------------------
# ControlCenter PDF report parsing
# -------------------------------------------------------------------------

def _to_float_locale(value: str) -> float:
    """Convert a string with . or , as decimal separator to float."""
    if value is None:
        return 0.0
    s = (
        str(value)
        .strip()
        .replace(" ", "")
        .replace("\u00a0", "")  # remove non-breaking spaces
    )
    s = s.replace(",", ".")
    try:
        return float(s)
    except Exception:
        return 0.0


def parse_controlcenter_pdf(pdf_bytes: bytes) -> Dict[str, Any]:
    """
    Parse a ControlCenter job report PDF and return a dict with:
    - width_m: job width in metres
    - length_m: job length in metres
    - job_name: file / job name (if found)
    - ml_map_m2: dict channel -> ml/mÂ² (Fixation mapped separately)
    - raw_text: concatenated text extracted from the first pages
    """
    if PdfReader is None:
        raise RuntimeError(
            "PyPDF2 is not available. Install it with 'pip install PyPDF2'."
        )

    reader = PdfReader(io.BytesIO(pdf_bytes))
    text_parts: List[str] = []
    for page in reader.pages[:2]:
        page_text = page.extract_text() or ""
        text_parts.append(page_text)
    text = "\n".join(text_parts)

    # Job name (Spanish examples)
    job_name = ""
    m_name = re.search(
        r"Nombre\s+del\s+archivo\s+(.+)",
        text,
        flags=re.IGNORECASE,
    )
    if m_name:
        job_name = m_name.group(1).strip()

    # Size, examples:
    # 'TamaÃ±o 1.74 m x 0.20 m'  or  'Tamano 1.74 m x 0.20 m'
    width_m = 0.0
    length_m = 0.0
    m_size = re.search(
        r"(Tama\u00f1o|Tamano)\s+([\d\.,]+)\s*m\s*x\s*([\d\.,]+)\s*m",
        text,
        flags=re.IGNORECASE,
    )
    if m_size:
        width_m = _to_float_locale(m_size.group(2))
        length_m = _to_float_locale(m_size.group(3))

    # Ink table line â€“ ml/mÂ² row
    ml_map_m2: Dict[str, float] = {}

    pattern_ml = r"ml\s*/\s*m[Â²2]?\s+((?:[\d.,]+\s+){3,}[\d.,]+)"
    ml_line_numbers: List[str] = []

    m_ml = re.search(pattern_ml, text, flags=re.IGNORECASE)
    if m_ml:
        ml_line_numbers = re.findall(r"[\d.,]+", m_ml.group(1))

    if not ml_line_numbers:
        candidate_line = ""
        for line in text.splitlines():
            if "ml/m" in line.lower():
                nums_in_line = re.findall(r"[\d.,]+", line)
                if len(nums_in_line) >= 4:
                    candidate_line = line
                    ml_line_numbers = nums_in_line
                    break

    if ml_line_numbers:
        values = [_to_float_locale(n) for n in ml_line_numbers]

        channels_order = [
            "Cyan",
            "Magenta",
            "Yellow",
            "Black",
            "Red",
            "Green",
            "Fixation",
            "Total",
        ]

        for ch, val in zip(channels_order, values):
            if ch == "Total":
                continue
            ml_map_m2[ch] = val

    return {
        "width_m": width_m,
        "length_m": length_m,
        "job_name": job_name,
        "ml_map_m2": ml_map_m2,
        "raw_text": text,
    }


# -------------------------------------------------------------------------
# Core job simulation
# -------------------------------------------------------------------------

def simulate_job(
    width_m: float,
    length_m: float,
    waste_pct: float,
    speed_m2h: float,
    ml_map_m2: Dict[str, float],
    ink_color_per_l: float,
    ink_white_per_l: float,
    fof_per_l: float,
    fabric_cost_per_m2: float,
    others_var_per_m2: float,
    labour_cost_total: float,
) -> Dict[str, float]:
    """Compute area, time and cost metrics for a single job."""
    width_m = max(0.0, width_m)
    length_m = max(0.0, length_m)
    waste_pct = max(0.0, waste_pct)

    base_area_m2 = width_m * length_m
    length_with_waste = length_m * (1.0 + waste_pct / 100.0)
    area_with_waste = base_area_m2 * (1.0 + waste_pct / 100.0)

    speed_m2h = max(0.0, speed_m2h)
    time_print_h = (base_area_m2 / speed_m2h) if speed_m2h > 0 else 0.0

    color_ml = 0.0
    white_ml = 0.0
    fof_ml = 0.0
    for k, v in (ml_map_m2 or {}).items():
        key_lower = (k or "").strip().lower()
        v_float = float(v or 0.0)
        if key_lower in CHANNELS_WHITE:
            white_ml += v_float
        elif key_lower in CHANNELS_FOF:
            fof_ml += v_float
        else:
            color_ml += v_float

    total_ml_per_m2 = color_ml + white_ml + fof_ml
    ink_ml_total = total_ml_per_m2 * area_with_waste

    cost_ink = (
        (color_ml / 1000.0) * ink_color_per_l +
        (white_ml / 1000.0) * ink_white_per_l +
        (fof_ml   / 1000.0) * fof_per_l
    ) * area_with_waste

    cost_media = fabric_cost_per_m2 * area_with_waste
    cost_other = others_var_per_m2 * area_with_waste
    cost_labour = labour_cost_total

    total_cost = cost_ink + cost_media + cost_other + cost_labour

    cost_per_m2 = total_cost / area_with_waste if area_with_waste > 0 else 0.0
    cost_per_m = total_cost / length_with_waste if length_with_waste > 0 else 0.0

    return dict(
        width_m=width_m,
        length_m=length_m,
        waste_pct=waste_pct,
        base_area_m2=base_area_m2,
        area_with_waste=area_with_waste,
        length_with_waste=length_with_waste,
        time_print_h=time_print_h,
        color_ml_per_m2=color_ml,
        white_ml_per_m2=white_ml,
        fof_ml_per_m2=fof_ml,
        total_ml_per_m2=total_ml_per_m2,
        ink_ml_total=ink_ml_total,
        cost_ink=cost_ink,
        cost_media=cost_media,
        cost_other=cost_other,
        cost_labour=cost_labour,
        total_cost=total_cost,
        cost_per_m2=cost_per_m2,
        cost_per_m=cost_per_m,
    )


def compute_full_job(
    width_m: float,
    length_m: float,
    waste_pct: float,
    speed_m2h: float,
    ml_map_m2: Dict[str, float],
    ink_color_per_l: float,
    ink_white_per_l: float,
    fof_per_l: float,
    fabric_cost_per_m2: float,
    other_var_simple_per_m2: float,
    laser_people: float,
    laser_hours_job: float,
    laser_salary_month: float,
    laser_energy_cost_per_hour: float,
    laser_machine_value: float,
    laser_useful_life_years: float,
    laser_hours_per_month: float,
    sewing_cost_per_m: float,
    hours_month: float,
    labour_inputs: List[tuple],
    energy_cost_per_hour: float,
    machine_value: float,
    useful_life_years: float,
    machine_hours_per_month: float,
    post_h: float,
) -> Dict[str, Any]:
    """
    Run the whole calculation pipeline and return a dict with all metrics.
    Used once and stored in st.session_state["calc"].
    """
    base_area_m2 = width_m * length_m
    area_with_waste = base_area_m2 * (1.0 + waste_pct / 100.0)
    length_with_waste = length_m * (1.0 + waste_pct / 100.0)

    # ---------------------- SERVICES (LASER, SEWING, OTHERS) ----------------------

    # Laser cutting â€“ detailed cost (labour + energy + depreciation)
    if laser_people > 0 and laser_hours_job > 0 and hours_month > 0 and laser_salary_month > 0:
        laser_cost_per_hour_per_person = laser_salary_month / float(hours_month)
        laser_labour_cost = laser_cost_per_hour_per_person * laser_hours_job * laser_people
    else:
        laser_labour_cost = 0.0

    if laser_hours_job > 0 and laser_energy_cost_per_hour > 0:
        laser_energy_cost = laser_energy_cost_per_hour * laser_hours_job
    else:
        laser_energy_cost = 0.0

    if laser_machine_value > 0 and laser_useful_life_years > 0 and laser_hours_per_month > 0:
        laser_monthly_depreciation = laser_machine_value / (laser_useful_life_years * 12.0)
        laser_depreciation_per_hour = laser_monthly_depreciation / laser_hours_per_month
        laser_depreciation_cost = laser_depreciation_per_hour * laser_hours_job
    else:
        laser_monthly_depreciation = 0.0
        laser_depreciation_per_hour = 0.0
        laser_depreciation_cost = 0.0

    laser_total = laser_labour_cost + laser_energy_cost + laser_depreciation_cost

    sewing_total = sewing_cost_per_m * length_with_waste
    others_simple_total = other_var_simple_per_m2 * area_with_waste

    others_total = laser_total + sewing_total + others_simple_total
    others_var_per_m2 = (others_total / area_with_waste) if area_with_waste > 0 else 0.0

    # ---------------------- LABOUR (PRESTO + OTHER ROLES) ----------------------

    labour_cost_total = 0.0
    labour_breakdown = []
    filtered_labour_inputs = []
    for label, salary, hours_job, qty in labour_inputs:
        if salary > 0 and hours_job > 0 and hours_month > 0 and qty > 0:
            cost_per_h = salary / float(hours_month)
            cost_job_per_person = cost_per_h * hours_job
            cost_job_total = cost_job_per_person * qty
            labour_cost_total += cost_job_total
            labour_breakdown.append(
                (label, cost_per_h, hours_job, qty, cost_job_per_person, cost_job_total)
            )
            filtered_labour_inputs.append((label, salary, hours_job, qty))

    # ---------------------- CORE JOB (INK, FABRIC, ETC.) ----------------------

    res = simulate_job(
        width_m=width_m,
        length_m=length_m,
        waste_pct=waste_pct,
        speed_m2h=speed_m2h,
        ml_map_m2=ml_map_m2,
        ink_color_per_l=ink_color_per_l,
        ink_white_per_l=ink_white_per_l,
        fof_per_l=fof_per_l,
        fabric_cost_per_m2=fabric_cost_per_m2,
        others_var_per_m2=others_var_per_m2,
        labour_cost_total=labour_cost_total,
    )

    # ---------------------- DEPRECIATION (PRESTO MAX) ----------------------

    if machine_value > 0 and useful_life_years > 0 and machine_hours_per_month > 0:
        monthly_depreciation = machine_value / (useful_life_years * 12.0)
        depreciation_cost_per_hour = monthly_depreciation / machine_hours_per_month
    else:
        monthly_depreciation = 0.0
        depreciation_cost_per_hour = 0.0

    # Machine running time (Presto only)
    # Theoretical: print time + extra post-process time
    machine_time_h = res["time_print_h"] + max(post_h, 0.0)

    # If "Machine operator" has hours in this job, we use that as actual machine time
    operator_time_h = 0.0
    for label, _salary, hours_job, _qty in labour_inputs:
        if label.lower().startswith("machine operator"):
            operator_time_h = max(float(hours_job), 0.0)
            break

    if operator_time_h > 0:
        machine_time_h = operator_time_h

    # Energy + depreciation for the Presto (laser treated separately)
    time_total_h = machine_time_h
    cost_energy = energy_cost_per_hour * time_total_h
    cost_depreciation = depreciation_cost_per_hour * time_total_h

    total_cost_with_energy = res["total_cost"] + cost_energy + cost_depreciation
    cost_per_m2_with_energy = (
        total_cost_with_energy / res["area_with_waste"]
        if res["area_with_waste"] > 0 else 0.0
    )
    cost_per_m_with_energy = (
        total_cost_with_energy / res["length_with_waste"]
        if res["length_with_waste"] > 0 else 0.0
    )

    return dict(
        res=res,
        laser_total=laser_total,
        sewing_total=sewing_total,
        others_simple_total=others_simple_total,
        laser_labour=laser_labour_cost,
        laser_energy=laser_energy_cost,
        laser_monthly_depreciation=laser_monthly_depreciation,
        laser_depreciation_per_hour=laser_depreciation_per_hour,
        laser_depreciation_cost=laser_depreciation_cost,
        labour_breakdown=labour_breakdown,
        filtered_labour_inputs=filtered_labour_inputs,
        monthly_depreciation=monthly_depreciation,
        depreciation_per_hour=depreciation_cost_per_hour,
        time_total_h=time_total_h,
        cost_energy=cost_energy,
        cost_depreciation=cost_depreciation,
        total_cost_with_energy=total_cost_with_energy,
        cost_per_m2_with_energy=cost_per_m2_with_energy,
        cost_per_m_with_energy=cost_per_m_with_energy,
        ml_map_m2=ml_map_m2,
    )


def bottom_nav() -> None:
    """Render a small link at the bottom to scroll back to the top tabs."""
    st.markdown(
        """
        <div style="text-align:right; margin-top: 1.5rem;">
          <a href="#top-tabs"
            style="
              display:inline-block;
              padding:0.35rem 0.9rem;
              border-radius:999px;
              border:1px solid #e5e7eb;
              background:#f9fafb;
              cursor:pointer;
              font-size:0.85rem;
              text-decoration:none;
              color:#111827;
            ">
            â¬† Back to top tabs
          </a>
        </div>
        """,
        unsafe_allow_html=True,
    )


# -------------------------------------------------------------------------
# Streamlit app
# -------------------------------------------------------------------------

def currency_label() -> str:
    return st.session_state.get("currency_label", "$")


def main() -> None:
    st.set_page_config(
        page_title="Presto MAX â€” Job Cost Calculator",
        page_icon="ðŸ§µ",
        layout="wide",
    )
    st.markdown('<div id="top-tabs"></div>', unsafe_allow_html=True)

    # CSS
    st.markdown(
        """
        <style>
        :root{
          --ink-bg: #f6f8fc;
          --ink-panel: #f3f4f6;
          --ink-edge: #e6e9f1;
          --ink-text: #111827;
          --ink-muted: #6b7280;
          --ink-chip: #eef2f7;
          --ink-accent: #2563eb;
          --ink-white: #ffffff;
          --ink-shadow: 0 1px 2px rgba(16,24,40,.08), 0 4px 12px rgba(16,24,40,.06);
        }

        html, body, [data-testid="stAppViewContainer"], .block-container{
          background:var(--ink-bg) !important;
          color:var(--ink-text) !important;
          -webkit-font-smoothing: antialiased;
          -moz-osx-font-smoothing: grayscale;
        }

        h1,h2,h3,h4,h5,h6,
        p, small, label, span, div,
        .stMarkdown, [data-testid="stMarkdownContainer"] *{
          color:var(--ink-text) !important;
        }

        [data-testid="stCaptionContainer"] *{ color:var(--ink-muted) !important; }

        [data-testid="stMetric"]{
          background:var(--ink-panel);
          border:1px solid var(--ink-edge);
          border-radius:14px; padding:12px;
          box-shadow: var(--ink-shadow);
          min-height: 88px;
          min-width: 170px;
        }
        [data-testid="stMetricValue"], [data-testid="stMetricValue"] *{
          font-variant-numeric: tabular-nums !important;
        }
        </style>
        """,
        unsafe_allow_html=True,
    )

    # ---- Company header: Logitex logo + title ----
    header_col1, header_col2 = st.columns([1, 3])
    with header_col1:
        try:
            st.image("logitex.png", width=150)
        except Exception:
            st.write("")
    with header_col2:
        st.title("Presto MAX â€” Job Cost Calculator")
        st.caption(
            "Job cost calculator for a specific order (roll) on the Presto MAX printer."
        )

    # Global reset button â€“ clears all inputs and calculations
    if st.button("ðŸ”„ Reset all data", type="secondary", key="btn_reset_all"):
        st.session_state.clear()
        if hasattr(st, "rerun"):
            st.rerun()
        else:  # fallback for older versions
            st.experimental_rerun()

    if "calc" not in st.session_state:
        st.session_state["calc"] = None

    tab_job, tab_conf, tab_ink, tab_results, tab_price, tab_roi, tab_laser_price, tab_compare, tab_break = st.tabs(
    [
        "Job & print mode",
        "Configuration",
        "Ink consumption",
        "Cost results",
        "Selling price",
        "ROI & payback",
        "Laser service pricing",
        "Comparison",
        "Breakdown",
    ]
)

    # ------------------------- TAB: CONFIGURATION -------------------------
    with tab_conf:
        st.header("0. General settings & costs")

        col_curr, col_source = st.columns([1, 2])
        col_curr.text_input(
            "Currency symbol (e.g. $, â‚¬)",
            value=st.session_state.get("currency_label", "$"),
            key="currency_label",
        )
        consumption_source = col_source.radio(
            "Ink consumption source",
            ["Machine XML inside ZIP", "Manual (ml/mÂ²)", "ControlCenter PDF report"],
            index=0,
            horizontal=True,
        )
        col_source.caption("ðŸ‘‰ Upload the XML, manual data or ControlCenter PDF in the **Ink consumption** tab.")

        st.markdown("---")
        st.subheader("Ink costs (per litre, by channel group)")
        col_ink1, col_ink2, col_ink3 = st.columns(3)
        ink_color_per_l = col_ink1.number_input(
            f"Coloured ink ({currency_label()}/L)",
            min_value=0.0,
            value=200.0,
        )
        ink_white_per_l = col_ink2.number_input(
            f"White ink ({currency_label()}/L)",
            min_value=0.0,
            value=0.0,
        )
        fof_per_l = col_ink3.number_input(
            f"FOF / pretreatment ({currency_label()}/L)",
            min_value=0.0,
            value=50.0,
        )

        st.markdown("---")
        st.subheader("Fabric and variable costs")
        col_fab1, col_fab2 = st.columns(2)
        fabric_cost_per_m = col_fab1.number_input(
            f"Fabric/media ({currency_label()}/m)",
            min_value=0.0,
            value=5.4,
            help="Cost per linear meter. The width is taken from the job info.",
        )
        other_var_simple_per_m2 = col_fab2.number_input(
            f"Other variable costs ({currency_label()}/mÂ²)",
            min_value=0.0,
            value=0.0,
            help="Protective paper, chemicals, packaging, etc.",
        )

        st.markdown("---")
        st.subheader("Laser cutting â€“ detailed parameters")
        col_l1, col_l2, col_l3 = st.columns(3)
        laser_people = col_l1.number_input(
            "Number of people in laser cutting",
            min_value=0,
            value=0,
            step=1,
        )
        laser_hours_job = col_l2.number_input(
            "Hours required for laser cutting (this job)",
            min_value=0.0,
            value=0.0,
        )
        laser_salary_month = col_l3.number_input(
            f"Monthly salary per person in laser ({currency_label()})",
            min_value=0.0,
            value=0.0,
        )

        col_l4, col_l5 = st.columns(2)
        laser_power_kw = col_l4.number_input(
            "Laser machine power (kW)",
            min_value=0.0,
            value=0.0,
            help="Typical small laser cutter: 1.0â€“3.0 kW, big units can be higher.",
        )
        col_l5.caption(
            "Laser cutting cost = labour (people Ã— hours Ã— salary) "
            "+ laser energy (kW Ã— electricity price Ã— hours)."
        )

        col_laser_dep1, col_laser_dep2, col_laser_dep3 = st.columns(3)
        laser_machine_value = col_laser_dep1.number_input(
            f"Laser machine value ({currency_label()})",
            min_value=0.0,
            value=0.0,
        )
        laser_useful_life_years = col_laser_dep2.number_input(
            "Laser useful life (years)",
            min_value=1.0,
            value=5.0,
        )
        laser_hours_per_month = col_laser_dep3.number_input(
            "Laser working hours per month (h)",
            min_value=1.0,
            value=220.0,
        )

        st.markdown("---")
        st.subheader("Other additional services per metre")
        col_serv1, col_serv2 = st.columns(2)
        sewing_cost_per_m = col_serv1.number_input(
            f"Internal sewing ({currency_label()}/m)",
            min_value=0.0,
            value=0.0,
        )
        col_serv2.markdown("")

        st.markdown("---")
        st.subheader("Equipment â€“ energy & depreciation (Presto MAX)")
        col_energy1, col_energy2, col_energy3 = st.columns(3)
        energy_price_per_kwh = col_energy1.number_input(
            f"Electricity price ({currency_label()}/kWh)",
            min_value=0.0,
            value=0.50,
        )
        power_consumption_kw = col_energy2.number_input(
            "Machine power consumption (kW)",
            min_value=0.0,
            value=5.0,
        )
        machine_value = col_energy3.number_input(
            f"Machine value ({currency_label()})",
            min_value=0.0,
            value=0.0,
        )

        col_dep1, col_dep2 = st.columns(2)
        useful_life_years = col_dep1.number_input(
            "Useful life (years)",
            min_value=1.0,
            value=5.0,
        )
        machine_hours_per_month = col_dep2.number_input(
            "Machine working hours per month (h)",
            min_value=1.0,
            value=220.0,
        )

        energy_cost_per_hour = energy_price_per_kwh * power_consumption_kw
        laser_energy_cost_per_hour = energy_price_per_kwh * laser_power_kw

        st.markdown("---")
        st.subheader("Labour (monthly salary â†’ cost/h)")
        hours_month = st.number_input(
            "Working hours per month (h)",
            min_value=1,
            max_value=300,
            value=220,
            help="Typical value is around 220 h/month.",
        )

        roles = [
            ("operator", "Machine operator"),
            ("supervisor", "Operations supervisor"),
            ("designer", "Designer / pre-press"),
            ("sales", "Sales representative"),
            ("finishing", "Product finishing"),
        ]

        labour_inputs: List[tuple] = []
        for key, label in roles:
            st.markdown(f"**{label}**")
            col1, col2, col3 = st.columns(3)
            salary = col1.number_input(
                "Monthly salary",
                min_value=0.0,
                value=0.0,
                key=f"sal_{key}",
            )
            hours_job = col2.number_input(
                "Hours in this job",
                min_value=0.0,
                value=0.0,
                key=f"hours_job_{key}",
            )
            qty = col3.number_input(
                "Number of people",
                min_value=0,
                value=1,
                step=1,
                key=f"qty_{key}",
            )
            labour_inputs.append((label, salary, hours_job, qty))

        bottom_nav()

    # ------------------------- TAB: LASER SERVICE PRICING -----------------------
    with tab_laser_price:
        st.header("7. Laser Cutting Service Calculator")
        st.caption("Independent tool to estimate the cost and selling price for laser cutting services.")

        # --- 1. MAIN LASER JOB INPUTS (QUICK CALCULATOR) ---
        st.subheader("A. Main laser job cost (quick calculator)")

        col_las_in1, col_las_in2, col_las_in3 = st.columns(3)

        def_width = st.session_state.get("width_m", 1.50) or 1.50
        def_len = st.session_state.get("length_m", 100.0) or 100.0

        l_width = col_las_in1.number_input(
            "Roll width (m)",
            min_value=0.0,
            value=float(def_width),
            key="las_width",
            help="Usable width of the material on the laser table.",
        )
        l_length = col_las_in2.number_input(
            "Total length to cut (m)",
            min_value=0.0,
            value=float(def_len),
            key="las_length",
            help="Total linear metres that will be processed in this laser job.",
        )
        col_las_in3.markdown("")

        st.markdown("Define the cutting time for this laser job.")
        l_hours_job = st.number_input(
            "Total cutting time (hours)",
            min_value=0.0,
            value=1.0,
            step=0.5,
            help="Total time that the laser will be operating for this job.",
        )

        st.markdown("---")

        # --- 2. HOURLY LASER COST PARAMETERS (LABOUR, ENERGY, DEPRECIATION) ---
        st.subheader("B. Hourly cost structure for laser")

        with st.expander("âš™ï¸ Configure hourly costs (labour, energy, machine depreciation)", expanded=False):
            st.info(
                "The values below are based on the general configuration tab, "
                "but you can adjust them specifically for this laser calculation."
            )

            c_l1, c_l2, c_l3 = st.columns(3)
            val_people = laser_people if "laser_people" in locals() else 1
            val_salary = laser_salary_month if "laser_salary_month" in locals() else 1500.0
            val_hours_month = hours_month if "hours_month" in locals() else 220.0

            in_laser_people = c_l1.number_input(
                "Number of people in laser operation",
                value=int(val_people),
                min_value=0,
                key="in_l_ppl",
            )
            in_laser_salary = c_l2.number_input(
                f"Monthly salary per person ({currency_label()})",
                value=float(val_salary),
                min_value=0.0,
                key="in_l_sal",
            )
            in_hours_month = c_l3.number_input(
                "Working hours per month (h)",
                value=float(val_hours_month),
                min_value=1.0,
                key="in_l_hmonth",
            )

            c_l4, c_l5, c_l6 = st.columns(3)
            val_l_power = laser_power_kw if "laser_power_kw" in locals() else 2.0
            val_e_price = energy_price_per_kwh if "energy_price_per_kwh" in locals() else 0.50

            in_laser_power = c_l4.number_input(
                "Laser machine power (kW)",
                value=float(val_l_power),
                min_value=0.0,
                key="in_l_pow",
            )
            in_energy_price = c_l5.number_input(
                f"Electricity price ({currency_label()}/kWh)",
                value=float(val_e_price),
                min_value=0.0,
                key="in_l_eprice",
            )

            val_l_val = laser_machine_value if "laser_machine_value" in locals() else 50000.0
            val_l_life = laser_useful_life_years if "laser_useful_life_years" in locals() else 5.0
            val_l_hmonth = laser_hours_per_month if "laser_hours_per_month" in locals() else 220.0

            in_laser_value = c_l6.number_input(
                f"Laser machine value ({currency_label()})",
                value=float(val_l_val),
                min_value=0.0,
                key="in_l_val",
            )

            # Hourly rate calculations
            rate_labour = 0.0
            if in_hours_month > 0:
                rate_labour = (in_laser_salary / in_hours_month) * in_laser_people

            rate_energy = in_laser_power * in_energy_price

            rate_depreciation = 0.0
            if val_l_life > 0 and val_l_hmonth > 0:
                monthly_dep = in_laser_value / (val_l_life * 12.0)
                rate_depreciation = monthly_dep / val_l_hmonth

            total_rate_hour = rate_labour + rate_energy + rate_depreciation

            st.caption(
                f"Total hourly operating cost: {total_rate_hour:.2f} {currency_label()}/h "
                f"(Labour: {rate_labour:.2f} + Energy: {rate_energy:.2f} + "
                f"Depreciation: {rate_depreciation:.2f})"
            )

        # --- 3. MAIN LASER JOB RESULTS (COST + SUGGESTED SELLING PRICE) ---
        if l_hours_job > 0:
            cost_labour_total = rate_labour * l_hours_job
            cost_energy_total = rate_energy * l_hours_job
            cost_depr_total = rate_depreciation * l_hours_job

            laser_total_job = cost_labour_total + cost_energy_total + cost_depr_total
            laser_cost_per_m = laser_total_job / l_length if l_length > 0 else 0.0

            st.session_state["laser_main_summary"] = {
                "total_cost": laser_total_job,
                "cost_per_m": laser_cost_per_m,
                "hours": l_hours_job,
                "length_m": l_length,
            }
            st.session_state["laser_main_breakdown"] = {
                "labour": cost_labour_total,
                "energy": cost_energy_total,
                "depreciation": cost_depr_total,
            }

            st.subheader("C. Main laser cost results")
            col_res1, col_res2, col_res3 = st.columns(3)
            col_res1.metric(
                f"Total job cost ({currency_label()})",
                f"{laser_total_job:.2f}",
            )
            col_res2.metric(
                f"Cost per linear metre ({currency_label()})",
                f"{laser_cost_per_m:.2f}",
            )
            col_res3.metric(
                "Total cutting time",
                f"{l_hours_job:.2f} h",
            )

            st.markdown("**Cost breakdown (main laser job)**")
            fig_l, ax_l = plt.subplots(figsize=(5, 2.5))
            l_labels = ["Labour", "Energy", "Depreciation"]
            l_values = [cost_labour_total, cost_energy_total, cost_depr_total]
            ax_l.barh(l_labels, l_values)
            ax_l.set_title(f"Total cost: {laser_total_job:.2f} {currency_label()}")
            for i, v in enumerate(l_values):
                ax_l.text(v, i, f" {v:.2f}", va="center", fontsize=8)
            st.pyplot(fig_l)

            st.markdown("---")
            st.subheader("D. Selling price for main laser job")

            target_margin_main = st.number_input(
                "Desired profit margin for this laser job (%)",
                value=40.0,
                step=5.0,
                key="las_margin_main",
            )

            if target_margin_main < 100 and laser_total_job > 0:
                suggested_price_total = laser_total_job / (1 - target_margin_main / 100.0)
                suggested_price_m = suggested_price_total / l_length if l_length > 0 else 0.0
                profit_main = suggested_price_total - laser_total_job
            else:
                suggested_price_total = 0.0
                suggested_price_m = 0.0
                profit_main = 0.0

            col_p1, col_p2, col_p3 = st.columns(3)
            col_p1.metric(
                "Suggested price (total job)",
                f"{currency_label()} {suggested_price_total:.2f}",
            )
            col_p2.metric(
                "Suggested price (per metre)",
                f"{currency_label()} {suggested_price_m:.2f}",
            )
            col_p3.metric(
                "Estimated profit (total job)",
                f"{currency_label()} {profit_main:.2f}",
                delta=f"{target_margin_main:.0f}%",
            )
        else:
            st.warning("Please enter the cutting time to calculate the main laser cost.")

        st.markdown("---")
        st.subheader("E. Independent laser cutting job")

        st.markdown(
            "Use this section when you want to quote **laser cutting as a separate service**, "
            "independent from the printing job. Enter the dimensions and hours for this specific job."
        )

        col_ljob1, col_ljob2, col_ljob3 = st.columns(3)
        laser_job_width_m = col_ljob1.number_input(
            "Laser job width (m)",
            min_value=0.0,
            value=1.50,
            key="laser_job_width_m",
            help="Usable width of the material to be cut.",
        )
        laser_job_length_m = col_ljob2.number_input(
            "Laser job length (m)",
            min_value=0.0,
            value=100.0,
            key="laser_job_length_m",
            help="Total length that will be processed in this laser job.",
        )
        laser_job_waste_pct = col_ljob3.number_input(
            "Laser waste (%)",
            min_value=0.0,
            max_value=50.0,
            value=0.0,
            key="laser_job_waste_pct",
            help="Losses at start/end, tests, alignment, etc. for this laser job.",
        )

        length_laser_effective = laser_job_length_m * (1.0 + laser_job_waste_pct / 100.0)
        area_laser_effective = laser_job_width_m * length_laser_effective

        laser_hours_job_tab = st.number_input(
            "Hours required for this independent laser job",
            min_value=0.0,
            value=float(l_hours_job),
            key="laser_hours_job_tab",
            help="Total hours that the laser will operate for this specific job.",
        )

        if (
            in_laser_people > 0
            and laser_hours_job_tab > 0
            and in_hours_month > 0
            and in_laser_salary > 0
        ):
            laser_cost_per_hour_per_person_tab = in_laser_salary / float(in_hours_month)
            laser_labour_cost_tab = (
                laser_cost_per_hour_per_person_tab * laser_hours_job_tab * in_laser_people
            )
        else:
            laser_labour_cost_tab = 0.0

        if laser_hours_job_tab > 0 and rate_energy > 0:
            laser_energy_cost_tab = rate_energy * laser_hours_job_tab
        else:
            laser_energy_cost_tab = 0.0

        if laser_hours_job_tab > 0 and rate_depreciation > 0:
            laser_depreciation_cost_tab = rate_depreciation * laser_hours_job_tab
        else:
            laser_depreciation_cost_tab = 0.0

        laser_total_tab = laser_labour_cost_tab + laser_energy_cost_tab + laser_depreciation_cost_tab
        laser_cost_per_m_tab = (
            laser_total_tab / length_laser_effective if length_laser_effective > 0 else 0.0
        )

        df_laser_independent_summary = pd.DataFrame(
            [
                {
                    "Laser job width (m)": laser_job_width_m,
                    "Laser job length (m)": laser_job_length_m,
                    "Laser waste (%)": laser_job_waste_pct,
                    "Effective length (m, incl. waste)": length_laser_effective,
                    "Effective area (mÂ², incl. waste)": area_laser_effective,
                    "Hours required (h)": laser_hours_job_tab,
                    "Laser cost total": laser_total_tab,
                    "Laser cost per linear metre": laser_cost_per_m_tab,
                }
            ]
        )

        st.markdown("**Cost summary â€“ independent laser job**")
        col_lsum1, col_lsum2, col_lsum3, col_lsum4 = st.columns(4)
        col_lsum1.metric(
            f"Total laser cost ({currency_label()})",
            f"{laser_total_tab:.2f}",
        )
        col_lsum2.metric(
            "Effective length for laser (m)",
            f"{length_laser_effective:.2f}",
        )
        col_lsum3.metric(
            "Effective area for laser (mÂ²)",
            f"{area_laser_effective:.2f}",
        )
        col_lsum4.metric(
            f"Laser cost per linear metre ({currency_label()})",
            f"{laser_cost_per_m_tab:.4f}",
        )

        st.markdown("---")
        st.markdown("**Pricing scenarios â€“ independent laser job**")

        base_metric_laser = st.radio(
            "Base unit for independent laser selling price",
            ["Per job", "Per linear metre"],
            index=1,
            horizontal=True,
            key="laser_base_metric_radio",
        )

        if base_metric_laser.startswith("Per job"):
            base_cost_laser = laser_total_tab
            base_label_laser = f"Laser selling price per job ({currency_label()})"
            profit_label_laser = f"Laser profit per job ({currency_label()})"
        else:
            base_cost_laser = laser_cost_per_m_tab
            base_label_laser = f"Laser selling price per linear metre ({currency_label()})"
            profit_label_laser = f"Laser profit per linear metre ({currency_label()})"

        target_margin_laser = st.number_input(
            "Target profit margin for independent laser job (%)",
            min_value=0.0,
            max_value=300.0,
            value=30.0,
            key="target_margin_laser",
        )

        raw_margins_laser = [
            max(0.0, target_margin_laser - 10),
            max(0.0, target_margin_laser - 5),
            target_margin_laser,
            target_margin_laser + 5,
            target_margin_laser + 10,
        ]
        margins_laser = sorted({m for m in raw_margins_laser if m < 100.0})

        rows_laser = []
        for m in margins_laser:
            if base_cost_laser > 0 and m < 100.0:
                price = base_cost_laser / (1.0 - m / 100.0)
                profit = price - base_cost_laser
                markup = price / base_cost_laser if base_cost_laser > 0 else 0.0
            else:
                price = profit = markup = 0.0
            rows_laser.append(
                {
                    "Margin (%)": m,
                    base_label_laser: price,
                    profit_label_laser: profit,
                    "Markup (Ã— cost)": markup,
                }
            )

        df_laser = pd.DataFrame(rows_laser)
        col_tbl_ind, col_chart_ind = st.columns([1.4, 1])

        with col_tbl_ind:
            st.markdown("**Table â€“ Suggested prices for independent laser job**")
            st.dataframe(df_laser, use_container_width=True)

        with col_chart_ind:
            fig_lp, ax_lp = plt.subplots(figsize=(4.5, 3))
            ax_lp.bar(df_laser["Margin (%)"], df_laser[base_label_laser])
            ax_lp.set_xlabel("Margin (%)")
            ax_lp.set_ylabel(base_label_laser)
            ax_lp.set_title("Independent laser selling price vs. margin")
            fig_lp.tight_layout()
            st.pyplot(fig_lp)

        st.markdown("**User-defined price and real margin â€“ independent laser job**")
        col_lu1, col_lu2, col_lu3 = st.columns(3)
        selling_price_laser_user = col_lu1.number_input(
            base_label_laser,
            min_value=0.0,
            value=0.0,
            help="Enter the price you plan to charge for the independent laser service.",
            key="selling_price_laser_user",
        )

        if selling_price_laser_user > 0 and base_cost_laser > 0:
            profit_laser_user = selling_price_laser_user - base_cost_laser
            margin_laser_user_pct = (profit_laser_user / selling_price_laser_user) * 100.0
        else:
            profit_laser_user = 0.0
            margin_laser_user_pct = 0.0

        col_lu2.metric(
            profit_label_laser,
            f"{profit_laser_user:.4f}",
            help="Difference between selling price and cost per base unit.",
        )
        col_lu3.metric(
            "Real profit margin (%) â€“ independent laser job",
            f"{margin_laser_user_pct:.2f}%",
        )

        st.markdown("**Cost vs selling price vs profit â€“ independent laser job**")
        fig_lcp, ax_lcp = plt.subplots()
        labels_laser_unit = ["Laser cost per unit", "Selling price", "Profit per unit"]
        values_laser_unit = [
            base_cost_laser,
            selling_price_laser_user,
            profit_laser_user if profit_laser_user > 0 else 0.0,
        ]
        ax_lcp.bar(labels_laser_unit, values_laser_unit)
        ax_lcp.set_ylabel(f"Value ({currency_label()})")
        ax_lcp.set_title("Unit economics â€“ independent laser service")
        for i, v in enumerate(values_laser_unit):
            ax_lcp.text(i, v, f"{v:,.2f}", ha="center", va="bottom", fontsize=8)
        fig_lcp.tight_layout()
        st.pyplot(fig_lcp)

        st.markdown("---")
        st.subheader("Export laser service report")
        st.caption(
            "Download an Excel report with the main laser job, independent laser job and laser-only pricing scenarios."
        )

        main_summary = st.session_state.get("laser_main_summary")
        main_breakdown = st.session_state.get("laser_main_breakdown")

        if main_summary is not None:
            df_laser_main_summary = pd.DataFrame(
                [
                    {
                        "Total job cost": main_summary.get("total_cost", 0.0),
                        "Cost per linear metre": main_summary.get("cost_per_m", 0.0),
                        "Total length (m)": main_summary.get("length_m", 0.0),
                        "Cutting time (h)": main_summary.get("hours", 0.0),
                    }
                ]
            )
        else:
            df_laser_main_summary = pd.DataFrame()

        if main_breakdown is not None:
            df_laser_main_breakdown = pd.DataFrame(
                [{"Component": key.capitalize(), "Cost": value} for key, value in main_breakdown.items()]
            )
        else:
            df_laser_main_breakdown = pd.DataFrame()

        laser_excel_buffer = io.BytesIO()
        with pd.ExcelWriter(laser_excel_buffer, engine="xlsxwriter") as writer:
            if not df_laser_main_summary.empty:
                df_laser_main_summary.to_excel(
                    writer, sheet_name="Main_laser_job", index=False
                )
            if not df_laser_main_breakdown.empty:
                df_laser_main_breakdown.to_excel(
                    writer, sheet_name="Main_laser_breakdown", index=False
                )

            if not df_laser_independent_summary.empty:
                df_laser_independent_summary.to_excel(
                    writer, sheet_name="Independent_summary", index=False
                )
            if not df_laser.empty:
                df_laser.to_excel(
                    writer, sheet_name="Independent_scenarios", index=False
                )

        laser_excel_buffer.seek(0)

        st.download_button(
            "ðŸ“¥ Download laser service Excel report",
            data=laser_excel_buffer,
            file_name="laser_service_pricing_report.xlsx",
            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        )

        bottom_nav()

    # ------------------------- TAB: JOB & PRINT MODE ----------------------
    with tab_job:
        st.header("1. Job information & print mode")

        col_dim1, col_dim2, col_dim3 = st.columns(3)
        width_m = col_dim1.number_input(
            "Usable print width (m)",
            min_value=0.0,
            value=1.80,
        )
        length_m = col_dim2.number_input(
            "Total job length (m)",
            min_value=0.0,
            value=500.0,
        )
        waste_pct = col_dim3.number_input(
            "Waste (%)",
            min_value=0.0,
            max_value=50.0,
            value=3.0,
            help="Losses at start/end of roll, tests, joins, etc.",
        )

        st.markdown("---")
        col_mode, col_post = st.columns(2)
        mode_name = col_mode.selectbox(
            "Print mode",
            list(PRINT_MODES.keys()),
            index=2,
        )
        speed_m2h = float(PRINT_MODES[mode_name]["speed"])

        post_h = col_post.number_input(
            "Extra hours (post-process)",
            min_value=0.0,
            value=0.0,
            help="Washing, heavy finishing, etc.",
        )

        base_area_m2_job = width_m * length_m
        if speed_m2h > 0:
            est_time_h = base_area_m2_job / speed_m2h
        else:
            est_time_h = 0.0

        est_hours_int = int(est_time_h)
        est_minutes_int = int(max(0.0, (est_time_h - est_hours_int) * 60.0))

        st.markdown("### Estimated production time (Presto)")
        col_t1, col_t2 = st.columns(2)
        col_t1.metric(
            "Estimated time (hours)",
            f"{est_time_h:.2f} h",
        )
        col_t2.metric(
            "Estimated time (h + min)",
            f"{est_hours_int} h {est_minutes_int:02d} min",
        )

        st.session_state["width_m"] = width_m
        st.session_state["length_m"] = length_m

        bottom_nav()

    # ------------------------- TAB: INK CONSUMPTION -----------------------
    ml_map_m2: Dict[str, float] = {}
    ml_map_pdf: Dict[str, float] = {}
    has_ink_data = False

    with tab_ink:
        st.header("2. Ink consumption")

        if consumption_source.startswith("Machine"):
            st.subheader("XML source (machine ZIP)")
            up = st.file_uploader(
                "Upload the ZIP generated by the Presto MAX",
                type=["zip"],
                key="zip_upload",
            )
            if up is not None:
                zbytes = up.getvalue()
                xml_name, xml_bytes = pick_xml_from_zip(zbytes)
                if xml_bytes is None:
                    st.error("No XML file found inside the ZIP. Please check the file.")
                else:
                    ml_map_m2 = ml_per_m2_from_xml_bytes(xml_bytes)
                    has_ink_data = True
                    st.success(f"Found XML: `{xml_name}`")

                    df_xml = pd.DataFrame(
                        [{"Channel": k, "ml/mÂ²": v} for k, v in ml_map_m2.items()]
                    )

                    col_xml_tbl, col_xml_chart = st.columns([1.1, 1.3])

                    with col_xml_tbl:
                        st.markdown("**Table â€“ Ink consumption per channel (ml/mÂ²)**")
                        st.dataframe(df_xml, use_container_width=True)

                    with col_xml_chart:
                        st.markdown("**Chart â€“ Ink consumption per channel (ml/mÂ²)**")
                        fig_xml, ax_xml = plt.subplots(figsize=(6.5, 4.0))
                        channels_xml = df_xml["Channel"]
                        values_xml = df_xml["ml/mÂ²"]
                        colors_xml = PALETTE_MAIN[: len(channels_xml)]
                        ax_xml.barh(channels_xml, values_xml, color=colors_xml)
                        ax_xml.set_xlabel("ml/mÂ²")
                        ax_xml.set_title("Ink consumption per channel (from XML)")
                        for i, v in enumerate(values_xml):
                            ax_xml.text(
                                v,
                                i,
                                f"{v:,.2f}",
                                va="center",
                                ha="left",
                                fontsize=8,
                            )
                        fig_xml.tight_layout()
                        st.pyplot(fig_xml)
            else:
                st.info("Upload the machine ZIP to automatically calculate consumption.")

        elif consumption_source.startswith("Manual"):
            st.subheader("Manual consumption (ml/mÂ²)")
            col_c, col_w, col_f = st.columns(3)
            man_color = col_c.number_input("Color (ml/mÂ²)", min_value=0.0, value=8.0)
            man_white = col_w.number_input("White (ml/mÂ²)", min_value=0.0, value=0.0)
            man_fof = col_f.number_input(
                "FOF / pretreatment (ml/mÂ²)", min_value=0.0, value=3.0
            )
            ml_map_m2 = {"Color": man_color, "White": man_white, "FOF": man_fof}
            has_ink_data = True

        else:
            st.subheader("ControlCenter PDF report")
            if PdfReader is None:
                st.error(
                    "PDF reading is disabled. Install the 'PyPDF2' package "
                    "with `pip install PyPDF2` to use this option."
                )
            else:
                up_pdf = st.file_uploader(
                    "Upload the ControlCenter job report (PDF)",
                    type=["pdf"],
                    key="pdf_upload_controlcenter",
                )
                if up_pdf is not None:
                    pdf_bytes = up_pdf.getvalue()
                    try:
                        info = parse_controlcenter_pdf(pdf_bytes)
                    except Exception as e:
                        st.error(f"Could not parse the ControlCenter PDF: {e}")
                    else:
                        ml_map_m2 = info.get("ml_map_m2", {}) or {}
                        ml_map_pdf = dict(ml_map_m2)

                        if not ml_map_m2:
                            st.error(
                                "No ink consumption line could be extracted from the PDF. "
                                "Please check that this is a valid ControlCenter job report."
                            )
                        else:
                            has_ink_data = True
                            width_pdf = float(info.get("width_m", 0.0))
                            length_pdf = float(info.get("length_m", 0.0))
                            job_name = info.get("job_name", "")

                            st.markdown("**Job data extracted from PDF**")
                            col_pdf1, col_pdf2, col_pdf3 = st.columns(3)
                            col_pdf1.metric(
                                "Job width from PDF (m)",
                                f"{width_pdf:.2f}",
                            )
                            col_pdf2.metric(
                                "Job length from PDF (m)",
                                f"{length_pdf:.2f}",
                            )
                            total_ml_m2 = sum(ml_map_m2.values())
                            col_pdf3.metric(
                                "Total ink + DS (ml/mÂ²)",
                                f"{total_ml_m2:.2f}",
                            )

                            if job_name:
                                st.caption(f"Job name: `{job_name}`")

                            df_pdf = pd.DataFrame(
                                [{"Channel": k, "ml/mÂ²": v} for k, v in ml_map_m2.items()]
                            )

                            col_pdf_tbl, col_pdf_chart = st.columns([1.1, 1.3])

                            with col_pdf_tbl:
                                st.markdown(
                                    "**Table â€“ Ink consumption per channel (ml/mÂ², from PDF)**"
                                )
                                st.dataframe(df_pdf, use_container_width=True)

                            with col_pdf_chart:
                                fig_pdf, ax_pdf = plt.subplots(figsize=(6.5, 4.0))
                                channels_pdf = df_pdf["Channel"]
                                values_pdf = df_pdf["ml/mÂ²"]

                                channel_color_map = {
                                    "Cyan": "#22c1dc",
                                    "Magenta": "#ec4899",
                                    "Yellow": "#eab308",
                                    "Black": "#111827",
                                    "Red": "#ef4444",
                                    "Green": "#22c55e",
                                    "Fixation": "#6b7280",
                                }

                                bar_colors = [
                                    channel_color_map.get(str(ch), PALETTE_MAIN[0])
                                    for ch in channels_pdf
                                ]

                                ax_pdf.barh(channels_pdf, values_pdf, color=bar_colors)
                                ax_pdf.set_xlabel("ml/mÂ²")
                                ax_pdf.set_title("Ink consumption per channel (from PDF)")
                                for i, v in enumerate(values_pdf):
                                    ax_pdf.text(
                                        v,
                                        i,
                                        f"{v:,.2f}",
                                        va="center",
                                        ha="left",
                                        fontsize=8,
                                    )
                                fig_pdf.tight_layout()
                                st.pyplot(fig_pdf)

                            st.info(
                                "Use the width and length values in the "
                                "**Job & print mode** tab if you want this job "
                                "to match exactly the ControlCenter report."
                            )
                else:
                    st.info(
                        "Upload the ControlCenter job report (PDF) to "
                        "automatically calculate ink and Duo Soft consumption."
                    )

        if ml_map_pdf:
            st.session_state["ml_map_pdf"] = ml_map_pdf

        st.session_state["ml_map_m2"] = ml_map_m2
        bottom_nav()

    # ------------------------- TAB: COST RESULTS --------------------------
    with tab_results:
        st.header("3. Cost results")

        ml_map_m2 = st.session_state.get("ml_map_m2", {}) or {}

        if st.button("Compute job cost", type="primary", key="btn_compute"):
            fabric_cost_per_m2_calc = (fabric_cost_per_m / width_m) if width_m > 0 else 0.0
            st.session_state["calc"] = compute_full_job(
                width_m=width_m,
                length_m=length_m,
                waste_pct=waste_pct,
                speed_m2h=speed_m2h,
                ml_map_m2=ml_map_m2,
                ink_color_per_l=ink_color_per_l,
                ink_white_per_l=ink_white_per_l,
                fof_per_l=fof_per_l,
                fabric_cost_per_m2=fabric_cost_per_m2_calc,
                other_var_simple_per_m2=other_var_simple_per_m2,
                laser_people=laser_people,
                laser_hours_job=laser_hours_job,
                laser_salary_month=laser_salary_month,
                laser_energy_cost_per_hour=laser_energy_cost_per_hour,
                laser_machine_value=laser_machine_value,
                laser_useful_life_years=laser_useful_life_years,
                laser_hours_per_month=laser_hours_per_month,
                sewing_cost_per_m=sewing_cost_per_m,
                hours_month=hours_month,
                labour_inputs=labour_inputs,
                energy_cost_per_hour=energy_cost_per_hour,
                machine_value=machine_value,
                useful_life_years=useful_life_years,
                machine_hours_per_month=machine_hours_per_month,
                post_h=post_h,
            )

        calc = st.session_state.get("calc")
        if not calc:
            st.info(
                "Adjust the configuration, job and ink data, then click "
                "**Compute job cost** to see the results."
            )
        else:
            res = calc["res"]
            cost_energy = calc["cost_energy"]
            cost_depreciation = calc["cost_depreciation"]
            total_cost_with_energy = calc["total_cost_with_energy"]
            cost_per_m2_with_energy = calc["cost_per_m2_with_energy"]
            cost_per_m_with_energy = calc["cost_per_m_with_energy"]

            st.subheader("Job summary")
            col_a, col_b, col_c = st.columns(3)
            col_a.metric(
                "Printed area (mÂ², incl. waste)",
                f"{res['area_with_waste']:.2f}",
            )
            col_b.metric(
                "Total length (m, incl. waste)",
                f"{res['length_with_waste']:.2f}",
            )
            col_c.metric(
                "Estimated print time (h)",
                f"{res['time_print_h']:.2f}",
            )

            st.markdown("### Total costs for this job")
            col1, col2, col3 = st.columns(3)
            col1.metric(
                f"Total job cost ({currency_label()})",
                f"{total_cost_with_energy:.2f}",
            )
            col2.metric(
                f"Cost per mÂ² ({currency_label()})",
                f"{cost_per_m2_with_energy:.4f}",
            )
            col3.metric(
                f"Cost per linear metre ({currency_label()})",
                f"{cost_per_m_with_energy:.4f}",
            )

            cost_ink = res["cost_ink"]
            cost_media = res["cost_media"]
            cost_other = res["cost_other"]
            cost_labour = res["cost_labour"]

            data_costs = [
                ("Ink", cost_ink),
                ("Fabric/media", cost_media),
                ("Other variables (incl. laser + sewing)", cost_other),
                ("Labour (all roles)", cost_labour),
                ("Energy", cost_energy),
                ("Depreciation", cost_depreciation),
            ]
            cost_col = f"Total cost ({currency_label()})"
            df_costs = pd.DataFrame(data_costs, columns=["Category", cost_col])

            st.markdown("### Cost breakdown by category")
            col_cost_tbl, col_cost_chart = st.columns([1.1, 1.3])

            with col_cost_tbl:
                st.markdown("**Table â€“ Cost by category (total job)**")
                st.dataframe(df_costs, use_container_width=True)

            with col_cost_chart:
                fig1, ax1 = plt.subplots(figsize=(6.5, 4.0))
                categories = df_costs["Category"]
                values = df_costs[cost_col]
                colors = PALETTE_MAIN[: len(categories)]
                ax1.barh(categories, values, color=colors)
                ax1.set_xlabel(cost_col)
                ax1.set_title("Cost by category")
                for i, v in enumerate(values):
                    ax1.text(
                        v,
                        i,
                        f"{v:,.2f}",
                        va="center",
                        ha="left",
                        fontsize=8,
                    )
                fig1.tight_layout()
                st.pyplot(fig1)

            st.markdown("### Share of total cost (%)")
            total_for_pct = df_costs[cost_col].sum() or 1.0
            df_pct = df_costs.copy()
            df_pct["% of total"] = (df_pct[cost_col] / total_for_pct) * 100.0

            col_pct_tbl, col_pct_chart = st.columns([1.1, 1.3])

            with col_pct_tbl:
                st.markdown("**Table â€“ Share of total cost (%)**")
                st.dataframe(df_pct, use_container_width=True)

            with col_pct_chart:
                fig2, ax2 = plt.subplots(figsize=(6.5, 4.0))
                categories_pct = df_pct["Category"]
                pct_values = df_pct["% of total"]
                colors_pct = PALETTE_MAIN[: len(categories_pct)]
                ax2.barh(categories_pct, pct_values, color=colors_pct)
                ax2.set_xlabel("% of total cost")
                ax2.set_title("Cost share (%) by category")
                ax2.set_xlim(0, 100)
                for i, v in enumerate(pct_values):
                    ax2.text(
                        v,
                        i,
                        f"{v:,.1f}%",
                        va="center",
                        ha="left",
                        fontsize=8,
                    )
                fig2.tight_layout()
                st.pyplot(fig2)

            st.success("Calculation complete. You can now explore the other tabs.")

            # -------------------- Export report (Excel & PDF) --------------------
            st.markdown("---")
            st.subheader("Export job report")

            labour_breakdown = calc["labour_breakdown"]
            filtered_labour_inputs = calc["filtered_labour_inputs"]
            laser_total = calc["laser_total"]
            sewing_total = calc["sewing_total"]
            others_simple_total = calc["others_simple_total"]
            monthly_depreciation = calc["monthly_depreciation"]
            depreciation_per_hour = calc["depreciation_per_hour"]
            time_total_h = calc["time_total_h"]

            df_summary = pd.DataFrame(
                [
                    {
                        "Printed area (mÂ², incl. waste)": res["area_with_waste"],
                        "Total length (m, incl. waste)": res["length_with_waste"],
                        "Estimated print time (h)": res["time_print_h"],
                        "Presto machine running time (h)": time_total_h,
                        "Total job cost": total_cost_with_energy,
                        "Cost per mÂ²": cost_per_m2_with_energy,
                        "Cost per linear metre": cost_per_m_with_energy,
                    }
                ]
            )

            if labour_breakdown:
                df_lab = pd.DataFrame(
                    [
                        {
                            "Role": label,
                            "Number of people": qty,
                            f"Monthly salary per person ({currency_label()})": salary,
                            "Cost per hour (per person)": cost_per_h,
                            "Hours in this job (per person)": hours_job,
                            f"Cost per person in this job ({currency_label()})": cost_job_per_person,
                            f"Total cost in this job ({currency_label()})": cost_job_total,
                        }
                        for (label, salary, hours_job, qty), (
                            _lbl2,
                            cost_per_h,
                            _hrs2,
                            _qty2,
                            cost_job_per_person,
                            cost_job_total,
                        ) in zip(filtered_labour_inputs, labour_breakdown)
                    ]
                )
            else:
                df_lab = pd.DataFrame()

            df_serv = pd.DataFrame(
                [
                    {
                        "Service": "Laser cutting (labour)",
                        "Base": "job",
                        "Total cost": calc.get("laser_labour", 0.0),
                    },
                    {
                        "Service": "Laser cutting (energy)",
                        "Base": "job",
                        "Total cost": calc.get("laser_energy", 0.0),
                    },
                    {
                        "Service": "Laser cutting (depreciation)",
                        "Base": "job",
                        "Total cost": calc.get("laser_depreciation_cost", 0.0),
                    },
                    {
                        "Service": "Laser cutting (total)",
                        "Base": "job",
                        "Total cost": laser_total,
                    },
                    {
                        "Service": "Internal sewing",
                        "Base": "per metre",
                        "Total cost": sewing_total,
                    },
                    {
                        "Service": "Other simple variables",
                        "Base": "per mÂ²",
                        "Total cost": others_simple_total,
                    },
                ]
            )

            df_energy = pd.DataFrame(
                [
                    {"Metric": "Presto machine running time (h)", "Value": time_total_h},
                    {"Metric": f"Energy cost ({currency_label()})", "Value": cost_energy},
                    {
                        "Metric": f"Monthly depreciation ({currency_label()})",
                        "Value": monthly_depreciation,
                    },
                    {
                        "Metric": f"Depreciation cost per hour ({currency_label()}/h)",
                        "Value": depreciation_per_hour,
                    },
                    {
                        "Metric": f"Depreciation cost (this job) ({currency_label()})",
                        "Value": cost_depreciation,
                    },
                ]
            )

            excel_buffer = io.BytesIO()
            with pd.ExcelWriter(excel_buffer, engine="xlsxwriter") as writer:
                df_summary.to_excel(writer, sheet_name="Summary", index=False)
                df_costs.to_excel(writer, sheet_name="Costs_by_category", index=False)
                df_pct.to_excel(writer, sheet_name="Cost_share_pct", index=False)
                if not df_lab.empty:
                    df_lab.to_excel(writer, sheet_name="Labour", index=False)
                df_serv.to_excel(writer, sheet_name="Services", index=False)
                df_energy.to_excel(writer, sheet_name="Equipment", index=False)
            excel_buffer.seek(0)

            st.download_button(
                "ðŸ“Š Download Excel report",
                data=excel_buffer,
                file_name="presto_job_cost_report.xlsx",
                mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            )

            # --------- PDF (single-page summary) ----------
            if FPDF is None:
                st.info(
                    "PDF export is disabled. Install the 'fpdf2' package "
                    "(`pip install fpdf2`) to enable PDF reports."
                )
            else:
                cur_pdf = currency_label()
                try:
                    cur_pdf = cur_pdf.encode("ascii").decode("ascii")
                except Exception:
                    cur_pdf = "$"

                pdf = FPDF()
                pdf.set_auto_page_break(auto=True, margin=15)
                pdf.add_page()

                pdf.set_font("Arial", "B", 16)
                pdf.cell(0, 10, "Presto MAX - Job Cost Report", ln=True)

                pdf.set_font("Arial", size=11)
                pdf.ln(4)
                pdf.cell(
                    0,
                    8,
                    f"Printed area (m2, incl. waste): {res['area_with_waste']:.2f}",
                    ln=True,
                )
                pdf.cell(
                    0,
                    8,
                    f"Total length (m, incl. waste): {res['length_with_waste']:.2f}",
                    ln=True,
                )
                pdf.cell(
                    0,
                    8,
                    f"Estimated print time (h): {res['time_print_h']:.2f}",
                    ln=True,
                )
                pdf.cell(
                    0,
                    8,
                    f"Presto machine running time (h): {time_total_h:.2f}",
                    ln=True,
                )

                pdf.ln(4)
                pdf.cell(
                    0,
                    8,
                    f"Total job cost ({cur_pdf}): {total_cost_with_energy:.2f}",
                    ln=True,
                )
                pdf.cell(
                    0,
                    8,
                    f"Cost per m2 ({cur_pdf}): {cost_per_m2_with_energy:.4f}",
                    ln=True,
                )
                pdf.cell(
                    0,
                    8,
                    f"Cost per linear metre ({cur_pdf}): {cost_per_m_with_energy:.4f}",
                    ln=True,
                )

                pdf.ln(6)
                pdf.set_font("Arial", "B", 12)
                pdf.cell(0, 8, "Cost breakdown by category", ln=True)

                pdf.set_font("Arial", size=10)
                col1_w = 80
                col2_w = 40
                col3_w = 40
                pdf.cell(col1_w, 7, "Category", border=1)
                pdf.cell(col2_w, 7, f"Cost ({cur_pdf})", border=1)
                pdf.cell(col3_w, 7, "% of total", border=1, ln=True)

                for _, row in df_pct.iterrows():
                    pdf.cell(col1_w, 7, str(row["Category"]), border=1)
                    pdf.cell(col2_w, 7, f"{row[cost_col]:.2f}", border=1)
                    pdf.cell(col3_w, 7, f"{row['% of total']:.1f}%", border=1, ln=True)

                if calc.get("laser_total", 0.0) > 0:
                    pdf.ln(4)
                    pdf.set_font("Arial", "B", 12)
                    pdf.cell(0, 8, "Laser cutting services (summary)", ln=True)
                    pdf.set_font("Arial", size=10)
                    pdf.cell(
                        0,
                        6,
                        f"Laser total cost (labour + energy + depreciation): "
                        f"{calc['laser_total']:.2f} {cur_pdf}",
                        ln=True,
                    )

                pdf_buffer = io.BytesIO()
                pdf.output(pdf_buffer)
                pdf_buffer.seek(0)

                st.download_button(
                    "ðŸ“„ Download PDF report",
                    data=pdf_buffer,
                    file_name="presto_job_cost_report.pdf",
                    mime="application/pdf",
                )

            bottom_nav()

    # ------------------------- TAB: SELLING PRICE -------------------------
    with tab_price:
        st.header("4. Selling price & margins")

        calc = st.session_state.get("calc")
        if not calc:
            st.info("First compute the job cost in **Cost results**.")
        else:
            res = calc["res"]
            cost_per_m2 = calc["cost_per_m2_with_energy"]
            cost_per_m = calc["cost_per_m_with_energy"]

            st.subheader("A. Base unit for pricing")
            base_unit = st.radio(
                "Choose the base unit for pricing:",
                ["Per mÂ²", "Per linear metre"],
                index=1,
                horizontal=True,
            )
            if base_unit.startswith("Per mÂ²"):
                base_cost = cost_per_m2
                base_label = f"Selling price per mÂ² ({currency_label()})"
                profit_label = f"Profit per mÂ² ({currency_label()})"
            else:
                base_cost = cost_per_m
                base_label = f"Selling price per linear metre ({currency_label()})"
                profit_label = f"Profit per linear metre ({currency_label()})"

            st.markdown("---")
            st.subheader("B. Suggested prices by margin")

            col_marg1, col_marg2 = st.columns(2)
            target_margin = col_marg1.number_input(
                "Target profit margin (%)",
                min_value=0.0,
                max_value=300.0,
                value=40.0,
            )
            col_marg2.caption(
                "The table below will create a margin ladder around the target margin."
            )

            if base_cost <= 0:
                st.warning("Base cost is zero. Please check the cost calculation.")
            else:
                raw_margins = [
                    max(0.0, target_margin - 10),
                    max(0.0, target_margin - 5),
                    target_margin,
                    target_margin + 5,
                    target_margin + 10,
                ]
                margins = sorted({m for m in raw_margins if m < 100.0})

                rows = []
                for m in margins:
                    price = base_cost / (1.0 - m / 100.0)
                    profit = price - base_cost
                    markup = price / base_cost
                    rows.append(
                        {
                            "Margin (%)": m,
                            base_label: price,
                            profit_label: profit,
                            "Markup (Ã— cost)": markup,
                        }
                    )

                df_price = pd.DataFrame(rows)

                col_tbl, col_chart = st.columns([1.1, 1.3])
                with col_tbl:
                    st.markdown("**Table â€“ Suggested prices by margin**")
                    st.dataframe(df_price, use_container_width=True)
                with col_chart:
                    fig_p, ax_p = plt.subplots(figsize=(6, 4))
                    ax_p.bar(df_price["Margin (%)"], df_price[base_label])
                    ax_p.set_xlabel("Margin (%)")
                    ax_p.set_ylabel(base_label)
                    ax_p.set_title("Selling price vs. margin")
                    for i, row in df_price.iterrows():
                        ax_p.text(
                            row["Margin (%)"],
                            row[base_label],
                            f"{row[base_label]:.2f}",
                            ha="center",
                            va="bottom",
                            fontsize=8,
                        )
                    fig_p.tight_layout()
                    st.pyplot(fig_p)

                st.markdown("---")
                st.subheader("C. User-defined selling price â€“ real margin")

                col_u1, col_u2, col_u3 = st.columns(3)
                user_price = col_u1.number_input(
                    base_label,
                    min_value=0.0,
                    value=0.0,
                    help="Type the selling price you plan to charge.",
                )

                if user_price > 0 and base_cost > 0:
                    profit_user = user_price - base_cost
                    margin_user = (profit_user / user_price) * 100.0
                else:
                    profit_user = 0.0
                    margin_user = 0.0

                col_u2.metric(
                    profit_label,
                    f"{profit_user:.4f}",
                )
                col_u3.metric(
                    "Real profit margin (%)",
                    f"{margin_user:.2f}%",
                )

                st.markdown("**Unit economics â€“ cost vs price vs profit**")
                fig_u, ax_u = plt.subplots()
                labels_u = ["Cost per unit", "Selling price", "Profit per unit"]
                values_u = [
                    base_cost,
                    user_price,
                    profit_user if profit_user > 0 else 0.0,
                ]
                ax_u.bar(labels_u, values_u)
                ax_u.set_ylabel(f"Value ({currency_label()})")
                ax_u.set_title("Unit economics â€“ selected base unit")
                for i, v in enumerate(values_u):
                    ax_u.text(i, v, f"{v:,.4f}", ha="center", va="bottom", fontsize=8)
                fig_u.tight_layout()
                st.pyplot(fig_u)

        bottom_nav()

    # ------------------------- TAB: ROI & PAYBACK (Modified) -------------------------
    with tab_roi:
        st.header("6. Machine Payback & ROI Simulator")
        st.caption("ProjeÃ§Ã£o de fluxo de caixa mensal e payback. Defina custos variÃ¡veis (detalhados), custos fixos (detalhados) e investimento.")

        sym = currency_label()
        
        # --- RECUPERAÃ‡ÃƒO DE DADOS (do Tab 3: Cost Results) ---
        calc = st.session_state.get("calc")
        
        # Defaults para Fixos
        def_monthly_depr = 0.0
        
        # Default para Investimento
        def_machine_val = 150000.0
        if 'machine_value' in locals() and machine_value > 0:
            def_machine_val = float(machine_value)
        
        if calc:
            # Tenta pegar depreciaÃ§Ã£o calculada no Tab 3
            if calc.get("monthly_depreciation"):
                def_monthly_depr = float(calc.get("monthly_depreciation"))

        # Layout em duas colunas principais
        econ_col, invest_col = st.columns([1.45, 1.0])
        
        with econ_col:
            st.markdown("**Unit Economics (Economia UnitÃ¡ria)**")
            
            unit_label_roi = st.selectbox("Unit Type", ["Linear Meter (m)", "Square Meter (mÂ²)", "Piece"], index=0)

            # Defaults for variable costs retrieval
            def_ink_cons_m2 = 0.0 # Default ml/m2 consumption
            def_media_lm = 5.4 # Default $/lm from config
            def_other_u = 0.0

            if 'fabric_cost_per_m' in locals():
                def_media_lm = float(fabric_cost_per_m)

            if calc:
                res = calc["res"]
                # Retrieve total ml per m2 from calculated job
                if res.get("total_ml_per_m2", 0.0) > 0:
                    def_ink_cons_m2 = res["total_ml_per_m2"]

                # Try to get other variable costs
                qty_ref = 1.0
                if "Square Meter" in unit_label_roi:
                    qty_ref = res.get("area_with_waste", 1.0)
                elif "Piece" in unit_label_roi:
                    qty_ref = 1.0
                else: # Linear Meter
                    qty_ref = res.get("length_with_waste", 1.0)
                
                if qty_ref > 0:
                    def_other_u = res["cost_other"] / qty_ref
            
            # 1. PREÃ‡O DE VENDA
            price_input = st.number_input(
                f"Price per {unit_label_roi}",
                min_value=0.0,
                value=15.0,
                step=0.50,
                format="%.2f",
                help="PreÃ§o de venda final por unidade."
            )
            
            # 2. CUSTOS VARIÃVEIS (DETALHADO vs TOTAL)
            st.markdown("---")
            var_mode = st.radio("Variable costs mode", ["Direct Total", "Detailed Breakdown"], index=1, horizontal=True)
            
            variable_per_unit_final = 0.0
            
            if var_mode == "Detailed Breakdown":
                st.caption("Detailed breakdown per unit.")
                
                # --- 2.1 Tinta (Calculada via $/L * ml/m2) ---
                col_ink_price, col_ink_cons = st.columns(2)
                ink_price_l = col_ink_price.number_input("Ink Price ($/Liter)", value=200.0, min_value=0.0)
                ink_cons_ml = col_ink_cons.number_input("Consumption (ml/mÂ²)", value=float(def_ink_cons_m2), min_value=0.0, format="%.2f")
                
                # Custo tinta por mÂ²
                v_ink_m2 = (ink_price_l / 1000.0) * ink_cons_ml
                
                # --- 2.2 MÃ­dia (Input em $/lm) ---
                col_media_p, col_other_p = st.columns(2)
                media_price_lm = col_media_p.number_input("Media Price ($/Linear Meter)", value=float(def_media_lm), min_value=0.0, format="%.2f")
                v_other = col_other_p.number_input(f"Other/{unit_label_roi}", value=float(def_other_u), min_value=0.0, step=0.1, format="%.2f")
                
                # --- ConversÃ£o para Unit Type selecionado ---
                job_width = width_m if width_m > 0 else 1.6 # Fallback width
                job_area = calc["res"]["area_with_waste"] if (calc and calc.get("res")) else 0.0

                # Calculate Final Cost components per SELECTED UNIT
                final_ink_cost = 0.0
                final_media_cost = 0.0

                if "Linear Meter" in unit_label_roi:
                    # Ink: cost/mÂ² * width
                    final_ink_cost = v_ink_m2 * job_width
                    # Media: input is already $/lm
                    final_media_cost = media_price_lm
                    
                elif "Square Meter" in unit_label_roi:
                    # Ink: already /mÂ²
                    final_ink_cost = v_ink_m2
                    # Media: $/lm / width
                    final_media_cost = media_price_lm / job_width if job_width > 0 else 0.0
                    
                elif "Piece" in unit_label_roi:
                    # Assume piece is the whole job area for simplicity or 1 unit logic
                    # Ideally we need piece area. Using Total Job Area if calc exists
                    final_ink_cost = v_ink_m2 * job_area
                    final_media_cost = (media_price_lm / job_width * job_area) if job_width > 0 else 0.0

                variable_per_unit_final = final_ink_cost + final_media_cost + v_other
                
                st.caption(f"Calc: Ink {pretty_money(final_ink_cost, sym)} + Media {pretty_money(final_media_cost, sym)} + Other {pretty_money(v_other, sym)}")
                st.markdown(f"**Total Variable Cost: {pretty_money(variable_per_unit_final, sym)} / {unit_label_roi}**")
                
            else:
                # Modo simples (total direto)
                variable_per_unit_final = st.number_input(
                    f"Total Variable Cost per {unit_label_roi}",
                    min_value=0.0,
                    value=5.0,
                    step=0.10,
                    format="%.2f"
                )

            # 3. VOLUME
            monthly_units_input = st.number_input(
                f"Monthly volume ({unit_label_roi}/month)",
                min_value=0.0,
                value=3000.0,
                step=100.0,
                help="ProduÃ§Ã£o mensal estimada."
            )

            # 4. CUSTOS FIXOS MENSAIS (DETALHADO vs TOTAL)
            st.markdown("---")
            st.markdown("**Monthly Fixed Costs (Custos Fixos Mensais)**")
            
            fix_mode = st.radio("Fixed costs mode", ["Direct Total", "Detailed (Monthly Helper)"], index=1, horizontal=True)
            
            total_fixed_monthly = 0.0
            depreciation_monthly_val = 0.0

            if fix_mode == "Detailed (Monthly Helper)":
                # --- General Fixed ---
                fc1, fc2 = st.columns(2)
                fc3, fc4 = st.columns(2)
                
                def_labor = 2000.0
                def_rent = 1000.0
                def_overhead = 500.0

                with fc1:
                    f_labor = st.number_input(f"Labor (Monthly) {sym}", value=def_labor, step=100.0)
                with fc2:
                    f_rent = st.number_input(f"Rent/Lease (Monthly) {sym}", value=def_rent, step=100.0)
                with fc3: 
                    f_over = st.number_input(f"Overheads (Monthly) {sym}", value=def_overhead, step=100.0)
                
                # --- Energy Section (NEW) ---
                st.markdown("###### Energy Consumption")
                e1, e2, e3 = st.columns(3)
                
                # Defaults
                def_kw = power_consumption_kw if 'power_consumption_kw' in locals() else 5.0
                def_kwh_price = energy_price_per_kwh if 'energy_price_per_kwh' in locals() else 0.50
                def_hours_mo = hours_month if 'hours_month' in locals() else 220.0

                p_kw = e1.number_input("Power (kW)", value=float(def_kw), step=0.1)
                p_kwh_price = e2.number_input(f"Price ({sym}/kWh)", value=float(def_kwh_price), step=0.01)
                p_hours = e3.number_input("Hours/Month", value=float(def_hours_mo), step=10.0)

                monthly_energy_cost = p_kw * p_kwh_price * p_hours
                st.caption(f"Monthly Energy: **{pretty_money(monthly_energy_cost, sym)}**")

                # --- Depreciation Calculator ---
                st.markdown("###### Depreciation Calculator")
                d1, d2 = st.columns(2)
                with d1:
                    depr_machine_val = st.number_input(f"Machine Value for Depr. ({sym})", value=def_machine_val, step=1000.0)
                with d2:
                    depr_years = st.number_input("Useful Life (Years)", value=5.0, min_value=1.0, step=1.0)
                
                f_depr_calc = depr_machine_val / (depr_years * 12.0)
                st.caption(f"Calculated Monthly Depreciation: **{pretty_money(f_depr_calc, sym)}**")

                total_fixed_monthly = f_labor + f_rent + f_over + monthly_energy_cost + f_depr_calc
                depreciation_monthly_val = f_depr_calc
                
                st.info(f"Total Monthly Fixed Costs: **{pretty_money(total_fixed_monthly, sym)}**")

            else:
                total_fixed_monthly = st.number_input(f"Total Monthly Fixed Costs {sym}", value=5000.0, step=100.0)
                depreciation_monthly_val = st.number_input(f"Of which is Depreciation {sym}", value=1000.0, step=100.0, help="Valor da depreciaÃ§Ã£o incluso no total acima.")

        with invest_col:
            st.markdown("**Investment & Ramp-up**")
            
            current_inv_default = depr_machine_val if (fix_mode == "Detailed (Monthly Helper)" and 'depr_machine_val' in locals()) else def_machine_val
            
            machine_investment = st.number_input(
                f"Machine investment ({sym})",
                min_value=0.0,
                value=float(current_inv_default),
                step=1000.0,
                help="Valor total do investimento (deve bater com o valor usado para depreciaÃ§Ã£o se for o mesmo ativo)."
            )
            
            residual_value = st.number_input(
                f"Residual value ({sym})",
                min_value=0.0,
                value=0.0,
                step=1000.0,
                help="Valor de revenda da mÃ¡quina ao final."
            )
            
            ramp_months = st.slider(
                "Ramp-up months", 0, 24, 3,
                help="Meses para atingir a produÃ§Ã£o total."
            )
            
            ramp_start_pct = st.slider(
                "Ramp start (%)", 0, 100, 40,
                help="% da produÃ§Ã£o no mÃªs 1."
            )
            
            growth_pct = st.number_input(
                "Monthly growth after ramp (%)",
                min_value=-10.0, max_value=100.0, value=0.0, step=0.5,
                help="Crescimento mensal apÃ³s o perÃ­odo de ramp-up."
            )
            
            horizon_months = st.slider("Analysis horizon (months)", 6, 120, 36)

        # --- CÃLCULO DO FLUXO DE CAIXA ---
        
        if monthly_units_input <= 0:
            st.warning("Enter a positive monthly volume.")
        elif price_input <= variable_per_unit_final:
            st.warning("Price must be greater than variable cost.")
        else:
            # Margem de ContribuiÃ§Ã£o UnitÃ¡ria
            contribution_unit = price_input - variable_per_unit_final
            
            # Custo Fixo "Cash" (Exclui depreciaÃ§Ã£o para cÃ¡lculo de fluxo de caixa)
            fixed_cash_outflow = max(0.0, total_fixed_monthly - depreciation_monthly_val)
            
            # Fluxo de Caixa EstÃ¡vel (Sem Rampa)
            steady_cash = (contribution_unit * monthly_units_input) - fixed_cash_outflow
            
            # Investimento LÃ­quido
            net_investment = max(0.0, machine_investment - residual_value)
            
            ramp_ratio = _clamp((ramp_start_pct or 0.0) / 100.0, 0.0, 1.0)
            growth_rate = float(growth_pct or 0.0) / 100.0

            payback_month, schedule, final_cumulative = compute_payback_schedule(
                net_investment,
                steady_cash,
                horizon_months,
                ramp_months,
                ramp_ratio,
                growth_rate,
            )

            payback_date = _add_months(dt.date.today(), payback_month) if payback_month else None

            # ExibiÃ§Ã£o de MÃ©tricas
            st.markdown("---")
            m1, m2, m3 = st.columns(3)
            m1.metric("Contribution per unit", pretty_money(contribution_unit, sym))
            m2.metric("Steady Monthly Net Cash", pretty_money(steady_cash, sym), help="Fluxo de caixa mensal lÃ­quido apÃ³s a fase de rampa (EBITDA proxy).")
            
            if payback_month:
                m3.metric("Payback (months)", f"{payback_month}")
                m3.caption(f"â‰ˆ {payback_date:%b %Y}")
            else:
                m3.metric("Payback", "Not reached")
                m3.caption(f"Net @ end: {pretty_money(final_cumulative, sym)}")

            # GrÃ¡fico Plotly
            cum_x = [0] + [int(row["month"]) for row in schedule]
            cum_y = [-net_investment] + [row["cumulative"] for row in schedule]

            fig = go.Figure()
            # Linha Acumulada
            fig.add_trace(
                go.Scatter(
                    x=cum_x,
                    y=cum_y,
                    mode="lines+markers",
                    name="Cumulative cash",
                    line=dict(color="#2563eb", width=3),
                    fill="tozeroy",
                )
            )
            # Barras Mensais
            if schedule:
                fig.add_trace(
                    go.Bar(
                        x=[int(row["month"]) for row in schedule],
                        y=[row["cash"] for row in schedule],
                        name="Monthly cash",
                        marker_color="#94a3b8",
                        opacity=0.6,
                    )
                )
            fig.add_hline(y=0, line_dash="dash", line_color="#9ca3af")
            
            if payback_month:
                fig.add_vline(
                    x=payback_month,
                    line_dash="dot",
                    line_color="#2563eb",
                    annotation_text=f"Payback M{payback_month}",
                    annotation_position="top right",
                )
                
            fig.update_layout(
                template="plotly_white",
                height=400,
                margin=dict(l=10, r=10, t=30, b=10),
                xaxis_title="Month",
                yaxis_title=f"{sym}",
                legend_title=None,
                hovermode="x unified"
            )
            st.plotly_chart(fig, use_container_width=True, config=plotly_cfg())

            # --- BREAKEVEN ANALYSIS CHART ---
            st.markdown("---")
            st.subheader("Breakeven Analysis")

            if contribution_unit > 0:
                breakeven_units = total_fixed_monthly / contribution_unit
                breakeven_revenue = breakeven_units * price_input

                m_be1, m_be2 = st.columns(2)
                m_be1.metric(f"Breakeven Point ({unit_label_roi})", f"{breakeven_units:,.2f}")
                m_be2.metric("Breakeven Point (revenue)", pretty_money(breakeven_revenue, sym))

                # Generate data for chart
                max_volume = max(monthly_units_input * 1.5, breakeven_units * 1.5)
                if max_volume == 0: max_volume = 1000 # fallback
                volume_range = np.linspace(0, max_volume, num=100)

                fixed_costs_line = [total_fixed_monthly] * 100
                total_revenue_line = volume_range * price_input
                total_costs_line = fixed_costs_line + (volume_range * variable_per_unit_final)

                # Create plotly figure
                fig_be = go.Figure()

                # Fixed Costs
                fig_be.add_trace(go.Scatter(x=volume_range, y=fixed_costs_line, mode='lines', name='Total Fixed Costs', line=dict(color='grey', dash='dash')))
                # Total Revenue
                fig_be.add_trace(go.Scatter(x=volume_range, y=total_revenue_line, mode='lines', name='Total Revenue', line=dict(color='#10B981')))
                # Total Costs
                fig_be.add_trace(go.Scatter(x=volume_range, y=total_costs_line, mode='lines', name='Total Costs', line=dict(color='#F59E0B')))

                # Breakeven point
                fig_be.add_vline(x=breakeven_units, line_dash="dot", line_color="#2563eb", annotation_text=f"Breakeven", annotation_position="top right")
                fig_be.add_hline(y=breakeven_revenue, line_dash="dot", line_color="#2563eb")

                fig_be.update_layout(
                    title="Breakeven Chart",
                    xaxis_title=f"Volume ({unit_label_roi})",
                    yaxis_title=f"Value ({sym})",
                    template="plotly_white",
                    legend_title=None,
                    hovermode="x unified"
                )
                st.plotly_chart(fig_be, use_container_width=True, config=plotly_cfg())

            else:
                st.warning("Cannot calculate breakeven point because Contribution per Unit is not positive.")

            # Tabela detalhada
            with st.expander("Show monthly schedule data", expanded=False):
                if schedule:
                    tbl = pd.DataFrame(schedule)
                    base_cash = steady_cash if abs(steady_cash) > 1e-9 else 1.0
                    tbl["Month"] = tbl["month"].astype(int)
                    tbl["Volume %"] = (tbl["cash"] / base_cash * 100.0).clip(lower=-999.0, upper=999.0).round(1)
                    tbl["Monthly Cash"] = tbl["cash"].apply(lambda v: pretty_money(v, sym))
                    tbl["Cumulative"] = tbl["cumulative"].apply(lambda v: pretty_money(v, sym))
                    st.dataframe(
                        tbl[["Month", "Volume %", "Monthly Cash", "Cumulative"]],
                        use_container_width=True,
                        hide_index=True
                    )
        
        bottom_nav()

    with tab_compare:
        st.header("8. Job Comparison")
        st.info("This feature is under development. It will allow you to compare two different job scenarios side-by-side.")
        bottom_nav()

    with tab_break:
        st.header("9. Detailed Cost Breakdown")
        calc = st.session_state.get("calc")
        if not calc:
            st.info("First compute the job cost in **Cost results** to see the breakdown.")
        else:
            sym = currency_label()

            # --- Labour Breakdown ---
            st.subheader("Labour Cost Breakdown")
            labour_breakdown = calc.get("labour_breakdown", [])
            if labour_breakdown:
                df_lab = pd.DataFrame(
                    [
                        {
                            "Role": label,
                            "Cost per Hour": cost_per_h,
                            "Hours in Job": hours_job,
                            "Num. People": qty,
                            f"Total Cost ({sym})": cost_job_total,
                        }
                        for label, cost_per_h, hours_job, qty, _, cost_job_total in labour_breakdown
                    ]
                )
                st.dataframe(df_lab, use_container_width=True)
            else:
                st.write("No labour costs entered.")

            # --- Other Variables / Services Breakdown ---
            st.subheader("Other Variable Costs Breakdown")
            other_costs = {
                "Laser Cutting (total)": calc.get("laser_total", 0.0),
                "Internal Sewing": calc.get("sewing_total", 0.0),
                "Other Simple Variables": calc.get("others_simple_total", 0.0),
            }
            df_other = pd.DataFrame(other_costs.items(), columns=["Service", f"Total Cost ({sym})"])
            st.dataframe(df_other, use_container_width=True)

            # --- Ink Breakdown ---
            st.subheader("Ink Cost Breakdown")
            res = calc["res"]
            area = res.get("area_with_waste", 1.0)
            if area > 0:
                rows = []
                # Color inks
                color_ml_total = res.get("color_ml_per_m2", 0.0) * area
                color_cost_total = (color_ml_total / 1000.0) * ink_color_per_l
                rows.append({"Channel Group": "Color Inks", "ml/mÂ²": res.get("color_ml_per_m2", 0.0), f"Total Cost ({sym})": color_cost_total})
                # White ink
                white_ml_total = res.get("white_ml_per_m2", 0.0) * area
                white_cost_total = (white_ml_total / 1000.0) * ink_white_per_l
                rows.append({"Channel Group": "White Ink", "ml/mÂ²": res.get("white_ml_per_m2", 0.0), f"Total Cost ({sym})": white_cost_total})
                # FOF
                fof_ml_total = res.get("fof_ml_per_m2", 0.0) * area
                fof_cost_total = (fof_ml_total / 1000.0) * fof_per_l
                rows.append({"Channel Group": "FOF/Pretreatment", "ml/mÂ²": res.get("fof_ml_per_m2", 0.0), f"Total Cost ({sym})": fof_cost_total})
                
                df_ink = pd.DataFrame(rows)
                st.dataframe(df_ink, use_container_width=True)
            else:
                st.write("No ink consumption data available.")

            # --- Depreciation Breakdown ---
            st.subheader("Depreciation Cost Breakdown")
            dep_costs = {
                "Presto MAX Machine": calc.get("cost_depreciation", 0.0),
                "Laser Machine": calc.get("laser_depreciation_cost", 0.0),
            }
            df_dep = pd.DataFrame(dep_costs.items(), columns=["Asset", f"Depreciation Cost for this Job ({sym})"])
            st.dataframe(df_dep, use_container_width=True)

            bottom_nav()


if __name__ == "__main__":
    main()